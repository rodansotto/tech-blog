---
layout: post
title: "Multi-threading in C#: Task-Based Asynchronous Pattern (TAP)"
date: "2022-09-06"
categories: "c-sharp"
---

![]({{ site.baseurl }}/assets/images/csthread.png)

[DEMO CODE](https://dotnetfiddle.net/xer6Iv) |

Since .NET Framework 4, [Task-Based Asynchronous Pattern (TAP)](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap?source=recommendations) is Microsoft's recommended way of developing multi-threaded applications in C# by Microsoft.  Before that, it was [Threads](https://docs.microsoft.com/en-us/dotnet/api/system.threading?view=net-6.0).  I've briefly covered the basics of threads and provided links about them in my 2017 post [Multi-threading in C#: A must have in your programming arsenal (IMO)](/tech-blog/2017/11/16/multi-threading-in-c-a-must-have-in-your-programming-arsenal-imo.html).  In fact all of the links there are still valid and are good resources for a refresher.

Briefly, [Tasks](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks?view=net-6.0) are part of Microsoft's [Task Parallel Libray (TPL)](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl) which also covers parallel programming.  For a complete guide to .NET's parallel programming, visit [Parallel programming in .NET](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/).

I have a demo code on my .NET Fiddle library, [Threads vs Tasks](https://dotnetfiddle.net/xer6Iv), illustrating how to program both threads and tasks in C#.  Tasks in C# is akin to [Promises in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).  It is much easier to code with tasks than with threads but with threads of course we have more control.  We do get code running faster with threads over tasks but less scalable in terms of memory, because with tasks thread pooling is automatic thereby reducing chance of running out of memory when scaling to a large number of running tasks.  We can implement thread pooling in threads but that complicates our code and thus much harder to understand.

Below is a sample output when running the demo code on my .NET Fiddle library:
```
Running Threads...
Worker 01 Thread Id 04: Running...
Worker 02 Thread Id 05: Running...
Worker 03 Thread Id 06: Running...
Worker 04 Thread Id 07: Running...
Worker 05 Thread Id 08: Running...
Worker 06 Thread Id 09: Running...
Worker 07 Thread Id 10: Running...
Worker 08 Thread Id 11: Running...
Worker 09 Thread Id 12: Running...
Worker 10 Thread Id 13: Running...
Worker 03 Thread Id 06: Done 100ms
Worker 01 Thread Id 04: Done 100ms
Worker 04 Thread Id 07: Done 100ms
Worker 02 Thread Id 05: Done 100ms
Worker 05 Thread Id 08: Done 100ms
Worker 06 Thread Id 09: Done 100ms
Worker 07 Thread Id 10: Done 100ms
Worker 08 Thread Id 11: Done 100ms
Worker 09 Thread Id 12: Done 100ms
Worker 10 Thread Id 13: Done 100ms
All Threads Completed 105ms

Running Tasks Using New, Start, and Wait...
Worker 02 Thread Id 16: Running...
Worker 01 Thread Id 14: Running...
Worker 03 Thread Id 18: Running...
Worker 04 Thread Id 17: Running...
Worker 02 Thread Id 16: Done 100ms
Worker 01 Thread Id 14: Done 100ms
Worker 03 Thread Id 18: Done 100ms
Worker 05 Thread Id 14: Running...
Worker 06 Thread Id 18: Running...
Worker 07 Thread Id 16: Running...
Worker 04 Thread Id 17: Done 100ms
Worker 08 Thread Id 17: Running...
Worker 05 Thread Id 14: Done 100ms
Worker 06 Thread Id 18: Done 100ms
Worker 10 Thread Id 18: Running...
Worker 09 Thread Id 14: Running...
Worker 07 Thread Id 16: Done 100ms
Worker 08 Thread Id 17: Done 100ms
Worker 10 Thread Id 18: Done 100ms
Worker 09 Thread Id 14: Done 100ms
All Tasks Completed 304ms

```
As you will notice, with threads, running a block of code in a thread always create a new thread and thus the total running time to complete any number of threads running the same block of code is almost always the same time it will take a single thread to finish running the block of code.  In this case, a block of code that takes a single thread to finish `100ms` will take a total running time of around `100ms` for any numbe of threads running the same block of code.  This is assuming we don't run out of threads in memory.

With tasks, since by default it uses thread pooling and manages it for us, every task does not necessarily create a new thread.  In this case, only 4 threads were created and reused to run our 10 tasks.  Because of this, the total running time to complete all 10 tasks running same block of code that only takes 100ms for a single task to finish, will in most cases if not all the time, be more than `100ms`, in this case, around `300ms`.  I think this total running time is very much dependent on how thread pool is being managed.  See [The managed thread pool](https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool) to learn more.

Tasks or not, we still need to be aware though of the availability of synchronization primitives and how to use them properly for when our tasks or threads need to share a resource or coordinate interaction.  In my next post or maybe my next demo code I will illustrate the use of these synchronization primitives.  For the meantime you can check [Overview of synchronization primitives](https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives) for a list of these synchronization primitives in C#.