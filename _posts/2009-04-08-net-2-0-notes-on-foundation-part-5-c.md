---
title: ".NET 2.0: Notes on Foundation Part 5 (C#)"
date: "2009-04-08"
categories: 
  - "net"
---

**Sequential Lists**

If you need a collection that stores data in a sequential basis, you can use a **Queue** which is a first-in, first-out (**FIFO**) or **Stack** which is a last-in, first-out (**LIFO**).  **Queue**’s most important properties and methods are: **Count**, **Dequeue()**, **Enqueue()**, and **Peek()**.  Stack’s most important properties and methods are: **Count**, **Pop()**, **Push()**, and **Peek()**.

**Dictionaries**

Dictionaries are another type of collections that are used to store key/value pairs.  The most basic of all dictionary classes that are available in .NET Framework is the **Hashtable** class.

<table border="0" cellspacing="0" cellpadding="0" width="630"><tbody><tr><td valign="top" width="628"><font size="2" face="Courier New">Hashtable emailLookup = <span style="color:#0000ff;">new</span> Hashtable();<br><br><span style="color:#008000;">// using Add() method</span><br><span style="color:#008000;">// where 1st parameter is the key and 2nd parameter is the value</span><br>emailLookup.Add(<span style="color:#006080;">"jdoe@company.com"</span>, <span style="color:#006080;">"Doe, John"</span>);<br><br><span style="color:#008000;">// using indexer to add key/value pair</span><br>emailLookup[<span style="color:#006080;">"jdoe@company.com"</span>] = <span style="color:#006080;">"Doe, John"</span>;<br><br><span style="color:#008000;">// using indexer to access data</span><br>Console.WriteLine(emailLookup[<span style="color:#006080;">"jdoe@company.com"</span>]);<br><br><span style="color:#008000;">// iterating through the entries in the dictionary</span><br><span style="color:#0000ff;">foreach</span> (DictionaryEntry entry <span style="color:#0000ff;">in</span> emailLookup)<br>{<br>&nbsp; Console.WriteLine(entry.Value);<br>}</font></td></tr></tbody></table>

All dictionary classes support the **IDictionary** interface which derives from **ICollection** interface.  **IDictionary**’s most important properties and methods are: **Keys**, **Values**, **Add()**, **Clear()**, **Contains()**, **GetEnumerator()**, and **Remove()**.  **Hashtable** also has additional methods for testing existence of keys and values: **ContainsKey()** and **ContainsValue()**.

**Hashtable and Equality**

The **Hashtable** uses a hash value, an integer, to aid in the storage of its keys.  It uses the **GetHash()** method that the **Object** class supports to test for equality.  The **Object**.**GetHash()** method returns a hash value that is unique to the object.  For **String** class, this **GetHash()** method is overridden so that two strings with the same text will be equal even though they are different instances. 

Care should be taken that when creating your own class that will be stored in a **Hashtable** that you override the **GetHash()** method if the test for equality is wrong.  You also might need to override the **Equals()** method because if the **Hashtable** finds that the two objects have same hash value, it will call their **Equals()** method to see if they are in fact equal.  The **Object.Equals()** method returns false if the two objects are different instances of the same class.

<table border="0" cellspacing="0" cellpadding="0" width="630"><tbody><tr><td valign="top" width="628"><font size="2"><font face="Courier New"><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> Dog<br>{<br><span style="color:#0000ff;">&nbsp; string</span> _name;<br><br><span style="color:#0000ff;">&nbsp; public</span> Dog(<span style="color:#0000ff;">string</span> name)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; _name = name;<br>&nbsp; }<br><br><span style="color:#0000ff;">&nbsp; public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">int</span> GetHashCode()<br>&nbsp; {<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp; return</span> name.GetHashCode();<br>&nbsp; }<br><br><span style="color:#0000ff;">&nbsp; public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">bool</span> Equals(<span style="color:#0000ff;">object</span> obj)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; Dog otherDog = obj <span style="color:#0000ff;">as</span> Dog;<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp; if</span> (otherDog == <span style="color:#0000ff;">null</span>) <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">false</span>;<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp; return</span> otherDog.name == name;<br>&nbsp; }<br>}</font></font></td></tr></tbody></table>

Another way to specify your own equality comparison is through the **IEqualityComparer** interface and this is useful if you do not want to change your classes to override the **GetHash()** and **Equals()** methods.

<table border="0" cellspacing="0" cellpadding="0" width="630"><tbody><tr><td valign="top" width="628"><font size="2"><font face="Courier New"><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> InsensitiveComparer : IEqualityComparer<br>{<br>&nbsp; CaseInsensitiveComparer _comparer = <span style="color:#0000ff;">new</span> CaseInsensitiveComparer();<br><br><span style="color:#0000ff;">&nbsp; public</span> <span style="color:#0000ff;">int</span> GetHashCode(<span style="color:#0000ff;">object</span> obj)<br>&nbsp; {<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp; return</span> obj.ToString().ToLowerInvariant().GetHashCode();<br>&nbsp; }<br><br><span style="color:#0000ff;">&nbsp; public</span> <span style="color:#0000ff;">new</span> <span style="color:#0000ff;">bool</span> Equals(<span style="color:#0000ff;">object</span> x, <span style="color:#0000ff;">object</span> y)<br>&nbsp; {<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp; if</span> (_comparer.Compare(x, y) == 0)<br>&nbsp;&nbsp;&nbsp; {<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</span> <span style="color:#0000ff;">true</span>;<br>&nbsp;&nbsp;&nbsp; }<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp; else</span><br>&nbsp;&nbsp;&nbsp; {<br><span style="color:#0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</span> <span style="color:#0000ff;">false</span>;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>}<br><br><span style="color:#008000;">// to use the InsensitiveComparer class</span><br>Hashtable dehash = <span style="color:#0000ff;">new</span> Hashtable(<span style="color:#0000ff;">new</span> InsensitiveComparer());<br>dehash[<span style="color:#006080;">"First"</span>] = <span style="color:#006080;">"1st"</span>;<br>dehash[<span style="color:#006080;">"Second"</span>] = <span style="color:#006080;">"2nd"</span>;<br>dehash[<span style="color:#006080;">"Third"</span>] = <span style="color:#006080;">"3rd"</span>;<br>dehash[<span style="color:#006080;">"Fourth"</span>] = <span style="color:#006080;">"4th"</span>;<br>dehash[<span style="color:#006080;">"fourth"</span>] = <span style="color:#006080;">"4th"</span>;<br>Console.WriteLine(dehash.Count); // 4</font></font></td></tr></tbody></table>
